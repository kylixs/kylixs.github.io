<a name="cJOko"></a>
## 前言
本文分析ByteBuddy 增强class（修改字节码）后，再次执行retransform class 失败的问题。<br />相关问题：[https://github.com/apache/skywalking/blob/master/docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md](https://github.com/apache/skywalking/blob/master/docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md)
> <a name="s55ot"></a>
### Problem
> 1. When using the SkyWalking agent, some other agents, such as Arthas, can't work properly. [#4858](https://github.com/apache/skywalking/pull/4858)
> 2. The retransform classes in the Java agent conflict with the SkyWalking agent, as illustrated in this [demo](https://github.com/SkyAPMTest/retransform-conflict-demo)
> <a name="VgKvy"></a>
### Cause
> The SkyWalking agent uses ByteBuddy to transform classes when the Java application starts. ByteBuddy generates auxiliary classes with different random names every time.
> When another Java agent retransforms the same class, it triggers the SkyWalking agent to enhance the class again. Since the bytecode has been regenerated by ByteBuddy, the fields and imported class names have been modified, and the JVM verifications on class bytecode have failed, the retransform classes would therefore be unsuccessful.


简单来说，ByteBuddy每次增强class时生成的辅助类(auxiliary)和代理方法名/字段名是随机的，导致同一个class第二次增强生成的方法和字段名与第一次生成的名称不同，故JVM认为改变class签名，抛出错误。
```java
java.lang.ClassFormatError
        at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
        at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:167)
        at com.example.demo.DemoApplication.reTransform(DemoApplication.java:69)
        at com.example.demo.DemoApplication.main(DemoApplication.java:30)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)
        at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49)
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:109)
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:58)
        at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88)
```
```java
retransform: class com.example.demo.TestController
Exception in thread "main" java.lang.reflect.InvocationTargetException
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)
        at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49)
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:109)
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:58)
        at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88)
Caused by: java.lang.UnsupportedOperationException: class redefinition failed: attempted to change the schema (add/remove fields)
        at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
        at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:167)
        at com.example.demo.DemoApplication.reTransform(DemoApplication.java:177)
        at com.example.demo.DemoApplication.testRetransformClass(DemoApplication.java:57)
        at com.example.demo.DemoApplication.main(DemoApplication.java:38)
        ... 8 more

```
<a name="scfdq"></a>
## 方法代理分析
下面通过几种不同方式对`Foo.sayHelloFoo()`进行代理, 并分析其实现原理。
```java
public class Foo {
    public String sayHelloFoo() {
        return "hello from foo";
    }
}
```
<a name="YpkIc"></a>
### 静态方法代理
将目标类的实例方法代理到代理类静态方法。<br />1）将原始方法改名为`sayHelloFoo$original$phKWXtvw`<br />2）创建同名方法`Foo`，改为调用代理类的静态方法`Bar.sayHelloDelegate()`，不再调用原始方法。
```java
// 1. delegate to static method
new AgentBuilder.Default()
        .type(ElementMatchers.named("com.example.demo.test.Foo"))
        .transform((builder, typeDescription, classLoader, module) -> builder
                .method(ElementMatchers.nameContainsIgnoreCase("sayHelloFoo"))
                .intercept(MethodDelegation.to(Bar.class))
        )
        .installOn(ByteBuddyAgent.install());
```
```java
public class Bar {
    public static String sayHelloDelegate() {
        return "hello from bar";
    }
}
```
```java
package com.example.demo.test;

import com.example.demo.test.Bar;

public class Foo {
   private /* synthetic */ String sayHelloFoo$original$phKWXtvw() {
/* 8*/         return "hello from foo";
   }

   static {
       ClassLoader.getSystemClassLoader().loadClass("net.bytebuddy.dynamic.Nexus").getMethod("initialize", Class.class, Integer.TYPE).invoke(null, Foo.class, 459118027);
   }

   public String sayHelloFoo() {
       return Bar.sayHelloDelegate();
   }
}
```
```
sayHello result: hello from bar
```
<a name="gczKk"></a>
### 切面（Advice）
类似Spring AOP，在方法的前后插入拦截代码。<br />1）将原始方法`Foo`改名为 `sayHelloFoo$original$K14bIcpb`<br />2）创建同名方法`Foo`，先调用enter拦截代码，然后调用原始方法`sayHelloFoo$original$K14bIcpb`，最后调用exit拦截代码。
```java
// 2. advice
new AgentBuilder.Default()
        .type(ElementMatchers.named("com.example.demo.test.Foo"))
        .transform((builder, typeDescription, classLoader, module) -> builder
                .method(ElementMatchers.nameContainsIgnoreCase("sayHelloFoo"))
                .intercept(Advice.to(HelloAdvice.class))
        )
        .installOn(ByteBuddyAgent.install());
```
```java
public class HelloAdvice {
    @Advice.OnMethodEnter(inline = false)
    public static long invokeBeforeEnterMethod(
            @Advice.Origin String method) {
        System.out.println("Method invoked before enter method by: " + method);
        return System.currentTimeMillis();
    }

    @Advice.OnMethodExit(inline = false)
    public static void invokeAfterExitMethod(
            @Advice.Origin String method,
            @Advice.Enter long startTime
    ) {
        System.out.println("Method " + method + " took " + (System.currentTimeMillis() - startTime) + "ms");
    }
}

```
```java
package com.example.demo.test;

import com.example.demo.HelloAdvice;

public class Foo {
   static {
       ClassLoader.getSystemClassLoader().loadClass("net.bytebuddy.dynamic.Nexus").getMethod("initialize", Class.class, Integer.TYPE).invoke(null, Foo.class, -1783898099);
   }

   public String sayHelloFoo() {
       long l = HelloAdvice.invokeBeforeEnterMethod((String)"public java.lang.String com.example.demo.test.Foo.sayHelloFoo()");
       Object object = this;
       object = ((Foo)object).sayHelloFoo$original$K14bIcpb();
       HelloAdvice.invokeAfterExitMethod((String)"public java.lang.String com.example.demo.test.Foo.sayHelloFoo()", (long)l);
       return object;
   }

   private /* synthetic */ String sayHelloFoo$original$K14bIcpb() {
/* 8*/         return "hello from foo";
   }
}
```
```
Method invoked before enter method by: public java.lang.String com.example.demo.test.Foo.sayHelloFoo()
Method public java.lang.String com.example.demo.test.Foo.sayHelloFoo() took 0ms
sayHello result: hello from foo
```
<a name="AnOJQ"></a>
### 拦截器（Interceptor）
修改原始方法，调用自定义的拦截器，在拦截器里面可以调用原始方法或者定制返回结果。<br />1）创建辅助类 `Foo$auxiliary$hMIW9t0B`继承`Callable`，包装原始实例和方法参数<br />2）插入拦截器字段 `InstMethodsInter delegate$5qlvaa1`<br />3）将原始方法`Foo`改名为 `sayHelloFoo$original$0UJsh7oQ`<br />4）创建同名方法`Foo`，调用拦截器`delegate$5qlvaa1.intercept()`方法，传入方法参数及辅助类对象<br />    public String sayHelloFoo() {<br />        return (String)**delegate$5qlvaa1.intercept**((Object)this, new Object[0], (Callable)new **Foo$auxiliary$hMIW9t0B**(this), cachedValue$kCAeBJto$6p6lul1);<br />    }<br />5）拦截器中通过辅助类对象调用原始方法 <br />// interceptor @SuperCall Callable<?> zuper<br /> `Object originResult = zuper.call()`<br />// 辅助类<br />    public Object call() throws Exception {<br />        return this.argument0.sayHelloFoo$original$0UJsh7oQ$accessor$kCAeBJto();<br />    }
```java
// 3. interceptor
new AgentBuilder.Default()
        .type(ElementMatchers.named("com.example.demo.test.Foo"))
        .transform((builder, typeDescription, classLoader, module) -> builder
                        .method(ElementMatchers.nameContainsIgnoreCase("sayHelloFoo"))
                        .intercept(MethodDelegation.withDefaultConfiguration()
                        .to(new InstMethodsInter(null, classLoader)))
        )
        .installOn(ByteBuddyAgent.install());

String result = new Foo()
        .sayHelloFoo();
System.out.println("sayHello result: " + result);
```
```java
public class InstMethodsInter {
    public InstMethodsInter(String interceptorClass, ClassLoader classLoader) {
    }

    @RuntimeType
    public Object intercept(@This Object obj, @AllArguments Object[] allArguments, @SuperCall Callable<?> zuper,
                            @Origin Method method) throws Throwable {

        Object originResult = zuper.call();
        Object newResult = originResult + "-new";
        System.out.printf("intercept: obj: %s, allArguments: %s, super: %s, method: %s, originResult: %s, newResult: %s\n",
                obj, Arrays.asList(allArguments), zuper, method, originResult, newResult);
        return newResult;
    }
}
```
```java
public class Foo {
    public String sayHelloFoo() {
        return "hello from foo";
    }
}

```
```java
package com.example.demo.test;

import com.example.demo.InstMethodsInter;
import com.example.demo.test.Foo$auxiliary$hMIW9t0B;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;

public class Foo {
    public static volatile /* synthetic */ InstMethodsInter delegate$5qlvaa1;
    private static final /* synthetic */ Method cachedValue$kCAeBJto$6p6lul1;

    static {
        ClassLoader.getSystemClassLoader().loadClass("net.bytebuddy.dynamic.Nexus").getMethod("initialize", Class.class, Integer.TYPE).invoke(null, Foo.class, -626677238);
        cachedValue$kCAeBJto$6p6lul1 = Foo.class.getMethod("sayHelloFoo", new Class[0]);
    }

    public String sayHelloFoo() {
        return (String)delegate$5qlvaa1.intercept((Object)this, new Object[0], (Callable)new Foo$auxiliary$hMIW9t0B(this), cachedValue$kCAeBJto$6p6lul1);
    }

    private /* synthetic */ String sayHelloFoo$original$0UJsh7oQ() {
        /* 8*/         return "hello from foo";
    }

    final /* synthetic */ String sayHelloFoo$original$0UJsh7oQ$accessor$kCAeBJto() {
        return this.sayHelloFoo$original$0UJsh7oQ();
    }
}
```
```java
package com.example.demo.test;

import com.example.demo.test.Foo;
import java.util.concurrent.Callable;

class Foo$auxiliary$hMIW9t0B implements Runnable, Callable {
    private Foo argument0;

    Foo$auxiliary$hMIW9t0B(Foo foo) {
        this.argument0 = foo;
    }

    @Override
    public void run() {
        this.argument0.sayHelloFoo$original$0UJsh7oQ$accessor$kCAeBJto();
    }

    public Object call() throws Exception {
        return this.argument0.sayHelloFoo$original$0UJsh7oQ$accessor$kCAeBJto();
    }
}
```
```
intercept: obj: com.example.demo.test.Foo@160c3ec1, 
  allArguments: [], 
  super: com.example.demo.test.Foo$auxiliary$hMIW9t0B@182b435b, 
  method: public java.lang.String com.example.demo.test.Foo.sayHelloFoo(), 
  originResult: hello from foo, 
  newResult: hello from foo-new

sayHello result: hello from foo-new
```

<a name="BlRFQ"></a>
## 关键问题
使用第3种方式的Interceptor代理时，每次执行retransformClass，都会动态创建一个辅助类并插入辅助类field，且类名和field name随机生成，不能复用之前的类/field。<br />第1次增强目标类字节码发生在class加载之前，可以插入field，可以正常执行；<br />**第2次增强目标类字节码时辅助类的field name和type和之前的不一样，JVM认为是新增或者删除了field**，提示错误：“java.lang.UnsupportedOperationException: class redefinition failed: attempted to change the schema (add/remove fields)”
```java
before retransform:
com.example.demo.test.Foo$auxiliary$qbGXYmht
com.example.demo.test.Foo

retransform:
java.lang.UnsupportedOperationException: class redefinition failed: attempted to change the schema (add/remove fields)
        at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
        at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:167)
        at com.example.demo.DemoApplication.reTransform(DemoApplication.java:122)
        at com.example.demo.DemoApplication.main(DemoApplication.java:44)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)
        at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49)
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:109)
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:58)
        at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88)

```

<a name="dqpkV"></a>
## 验证Demo
下面的代码解决了部分问题，上面的简单测试类已经通过，但挂载Skywalking Agent后，Controller还是报错。<br />[https://github.com/kylixs/retransform-conflict-demo/tree/delegate-test](https://github.com/kylixs/retransform-conflict-demo/tree/delegate-test)
```java
=========================
before retransform: com.example.demo.test.Foo
com.example.demo.test.Foo$auxiliary$4m69gq2
com.example.demo.test.Foo

retransform: class com.example.demo.test.Foo

after retransform: class com.example.demo.test.Foo
com.example.demo.test.Foo$auxiliary$4m69gq2
com.example.demo.test.Foo

check retransform classes:
retransform classes successful.
=========================
before retransform: com.example.demo.TestController
com.example.demo.TestController$auxiliary$o7b3Mmbs
com.example.demo.TestController
com.example.demo.TestController$auxiliary$xVJLr7D3

retransform: class com.example.demo.TestController
Exception in thread "main" java.lang.reflect.InvocationTargetException
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)
        at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49)
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:109)
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:58)
        at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88)
Caused by: java.lang.UnsupportedOperationException: class redefinition failed: attempted to change the schema (add/remove fields)
        at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
        at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:167)
        at com.example.demo.DemoApplication.reTransform(DemoApplication.java:167)
        at com.example.demo.DemoApplication.testRetransformClass(DemoApplication.java:63)
        at com.example.demo.DemoApplication.main(DemoApplication.java:44)
        ... 8 more

```

对比发现每次生成的TestController代码有较大差异：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1681661811717-253cf02b-7bee-4caa-9e34-0b533d1cbb8b.png#averageHue=%23e9e6d0&clientId=u79ccb49e-3ec7-4&from=paste&height=582&id=u901f8648&originHeight=1153&originWidth=2307&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=252429&status=done&style=none&taskId=uedbd2b63-1e0d-49da-b279-b959a655c56&title=&width=1165.1514337775886)

测试方法：<br />1）启动应用，挂载Skywalking agent
```bash
export JVM_OPS="-agentlib:jdwp=transport=dt_socket,server=y,address=*:5005,suspend=n -javaagent:/d/tool/skywalking-agent-8.15.0/skywalking-agent.jar "
java $JVM_OPS -jar target/retransform-conflict-demo.jar 
```

2）注入Arthas，多次执行`jad *TestController`<br />每次都会触发skywalking agent restransform

3）调试ByteBuddy代码，排查生成的差异field的数据来源。<br />关键代码方法：<br />net.bytebuddy.asm.AsmVisitorWrapper.ForDeclaredFields.DispatchingVisitor#visitField<br />net.bytebuddy.implementation.Implementation.Context.Default#register<br />net.bytebuddy.jar.asm.ClassVisitor#visitField<br />net.bytebuddy.dynamic.scaffold.InstrumentedType.Default#withField<br />net.bytebuddy.implementation.InvocationHandlerAdapter.ForInstance#prepare

<a name="EvWg9"></a>
## 代理方法名

代理方法名生成：MethodNameTransformer.transform(MethodDescription methodDescription)
```java
"main@1" prio=5 tid=0x1 nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer$Suffixing.transform(MethodNameTransformer.java:76)
	  at net.bytebuddy.dynamic.scaffold.inline.MethodRebaseResolver$Resolution$ForRebasedMethod$RebasedMethod.getInternalName(MethodRebaseResolver.java:325)
	  at net.bytebuddy.description.method.MethodDescription$AbstractBase.asSignatureToken(MethodDescription.java:905)
	  at net.bytebuddy.implementation.Implementation$SpecialMethodInvocation$AbstractBase.hashCode(Implementation.java:204)
	  at net.bytebuddy.implementation.auxiliary.MethodCallProxy.hashCode(MethodCallProxy.java:-1)
	  at java.util.HashMap.hash(HashMap.java:339)
	  at java.util.HashMap.get(HashMap.java:552)
	  at net.bytebuddy.implementation.Implementation$Context$Default.register(Implementation.java:1202)
	  at net.bytebuddy.implementation.auxiliary.MethodCallProxy$AssignableSignatureCall.apply(MethodCallProxy.java:460)
	  at net.bytebuddy.implementation.bind.MethodDelegationBinder$ParameterBinding$Anonymous.apply(MethodDelegationBinder.java:258)
	  at net.bytebuddy.implementation.bytecode.StackManipulation$Compound.apply(StackManipulation.java:243)
	  at net.bytebuddy.implementation.bind.MethodDelegationBinder$MethodBinding$Builder$Build.apply(MethodDelegationBinder.java:564)
	  at net.bytebuddy.implementation.bytecode.StackManipulation$Compound.apply(StackManipulation.java:243)
	  at net.bytebuddy.implementation.MethodDelegation$Appender.apply(MethodDelegation.java:1350)
	  at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyCode(TypeWriter.java:730)
	  at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyBody(TypeWriter.java:715)
	  at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining$WithFullProcessing$RedefinitionClassVisitor$CodePreservingMethodVisitor.visitCode(TypeWriter.java:5502)
	  at net.bytebuddy.jar.asm.ClassReader.readMethod(ClassReader.java:1513)
	  at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:744)
	  at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:424)
	  at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:4014)
	  at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:2224)
	  at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase$UsingTypeWriter.make(DynamicType.java:4057)
	  at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doTransform(AgentBuilder.java:12225)
	  at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:12160)
	  at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1800(AgentBuilder.java:11869)
	  at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:12647)
	  at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:12579)
	  at java.security.AccessController.doPrivileged(AccessController.java:-1)
	  at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doPrivileged(AgentBuilder.java:12055)
	  at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:12103)
	  at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$ByteBuddy$ModuleSupport.transform(Unknown Source:-1)
	  at sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	  at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:563)
	  at java.lang.ClassLoader.defineClass1(ClassLoader.java:-1)
	  at java.lang.ClassLoader.defineClass(ClassLoader.java:1016)
	  at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:174)
	  at java.net.URLClassLoader.defineClass(URLClassLoader.java:550)
	  at java.net.URLClassLoader$1.run(URLClassLoader.java:458)
	  at java.net.URLClassLoader$1.run(URLClassLoader.java:452)
	  at java.security.AccessController.doPrivileged(AccessController.java:-1)
	  at java.net.URLClassLoader.findClass(URLClassLoader.java:451)
	  at java.lang.ClassLoader.loadClass(ClassLoader.java:588)
	  - locked <0x1875> (a java.lang.Object)
	  at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:129)
	  at java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	  at com.example.demo.DemoApplication.transformWithByteBuddy(DemoApplication.java:145)
	  at com.example.demo.DemoApplication.main(DemoApplication.java:36)

```
MethodNameTransformer 原有Suffixing和Prefixing两个实现，都不是特别好，方法重载场景（方法同名参数不同）下不能生成唯一的名称。<br />自定义的扩展实现：SWMethodNameTransformer，并通过类反射注入到AgentBuilder。
```java
public class SWMethodNameTransformer implements MethodNameTransformer {

    private static final String DEFAULT_PREFIX = "original$";

    private String prefix;

    public SWMethodNameTransformer() {
        this(DEFAULT_PREFIX);
    }

    public SWMethodNameTransformer(String prefix) {
        this.prefix = prefix;
    }

    @Override
    public String transform(MethodDescription methodDescription) {
        return prefix + methodDescription.getInternalName() +"$"+ RandomString.hashOf(methodDescription.toString().hashCode());
    }

}
```

```java
public class NativeMethodStrategySupport {

    private static ILog LOGGER = LogManager.getLogger(NativeMethodStrategySupport.class);

    // 注意此方法必须在创建AgentBuilder后首先执行，避免AgentBuilder调用方法后生成的子类干扰
    public static void inject(AgentBuilder agentBuilder, Class clazz, String prefix) {
        try {
            Field nativeMethodStrategyField = clazz.getDeclaredField("nativeMethodStrategy");
            nativeMethodStrategyField.setAccessible(true);
            nativeMethodStrategyField.set(agentBuilder, new SWNativeMethodStrategy(prefix));
        } catch (Exception e) {
            LOGGER.error(e, "SkyWalking agent inject NativeMethodStrategy failure. clazz: " + clazz.getName());
        }
    }
}
```

<a name="FsQr8"></a>
## Method字段名
被代理的方法的Method对象会保存到字段 `Method cachedValue$xxx$xxx`，运行时传递给拦截器。
```java
   private static final /* synthetic */ Method cachedValue$8vbdac3$lr4pe70;
   private static final /* synthetic */ Method cachedValue$8vbdac3$lt7gtc1;
   static {
       ClassLoader.getSystemClassLoader().loadClass("org.apache.skywalking.apm.dependencies.net.bytebuddy.dynamic.Nexus").getMethod("initialize", Class.class, Integer.TYPE).invoke(null, TestController.class, -1339135612);
       cachedValue$8vbdac3$lr4pe70 = TestController.class.getMethod("testJdkHttpClient", new Class[0]);
       cachedValue$8vbdac3$lt7gtc1 = TestController.class.getMethod("test", new Class[0]);
   }

   @RequestMapping(value={"/test"})
   @ResponseBody
   public String test() {
       return (String)_sw_delegate$8vbdac3$5.intercept((Object)this, new Object[0], (Callable)new TestController$sw_auxiliary$63vome2(this), cachedValue$8vbdac3$lt7gtc1);
   }

   @RequestMapping(value={"/http"})
   @ResponseBody
   public String testJdkHttpClient() {
       return (String)_sw_delegate$8vbdac3$5.intercept((Object)this, new Object[0], (Callable)new TestController$sw_auxiliary$ca62532(this), cachedValue$8vbdac3$lr4pe70);
   }
```
```java
public class InstMethodsInterceptor {

    @RuntimeType
    public Object intercept(@This Object obj, @AllArguments Object[] allArguments, @SuperCall Callable<?> zuper,
                            @Origin Method method) throws Throwable {
        ...
    }
}
```

调试分析发现CacheValueField的生成方法：<br />net.bytebuddy.implementation.Implementation.Context.Default#cache<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682778981998-d26fcac3-19c7-4003-af25-d52592271e74.png#averageHue=%23f0efee&clientId=u50591a3e-6814-4&from=paste&height=390&id=u32d5e5b0&originHeight=773&originWidth=2344&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=175948&status=done&style=none&taskId=ue99abe85-3011-4bca-8524-898fb8241e1&title=&width=1183.8383011593705)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682779035232-dc042128-af5f-4fac-8886-a0eb62b15450.png#averageHue=%23f1eaea&clientId=u50591a3e-6814-4&from=paste&height=120&id=u60d49e25&originHeight=237&originWidth=1873&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=47966&status=done&style=none&taskId=u57dddeaf-b83b-4cfe-ace5-cfed6d239dd&title=&width=945.9595298939851)<br />追踪发现，这个suffix是随机生成的， 需要改为固定的。<br />net.bytebuddy.implementation.Implementation.Context.Default.Factory#make()<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682779155399-d18e886a-cc8f-4e23-8f54-69e72b91f921.png#averageHue=%23f0eeec&clientId=u50591a3e-6814-4&from=paste&height=304&id=uae3e2f6d&originHeight=602&originWidth=1273&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=75486&status=done&style=none&taskId=u69dcee49-d501-4e5e-b23b-e2e08b8252d&title=&width=642.929248027252)

自定义SWImplementationContextFactory
```java
public class SWImplementationContextFactory implements Implementation.Context.Factory {
    @Override
    public Implementation.Context.ExtractableView make(TypeDescription instrumentedType, 
                                                       AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, 
                                                       TypeInitializer typeInitializer, 
                                                       ClassFileVersion classFileVersion, 
                                                       ClassFileVersion auxiliaryClassFileVersion) {
        return this.make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, 
                auxiliaryClassFileVersion, Implementation.Context.FrameGeneration.GENERATE);
    }

    @Override
    public Implementation.Context.ExtractableView make(TypeDescription instrumentedType, 
                                                       AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, 
                                                       TypeInitializer typeInitializer, 
                                                       ClassFileVersion classFileVersion, 
                                                       ClassFileVersion auxiliaryClassFileVersion, 
                                                       Implementation.Context.FrameGeneration frameGeneration) {
        return new Implementation.Context.Default(instrumentedType, classFileVersion, auxiliaryTypeNamingStrategy, 
                typeInitializer, auxiliaryClassFileVersion, frameGeneration, 
                RandomString.hashOf(instrumentedType.getName().hashCode()));
    }
}
```
```java
final ByteBuddy byteBuddy = new ByteBuddy()
        .with(new SWImplementationContextFactory());
```
<a name="vWAEa"></a>
## 拦截器字段名
使用拦截器方式代理方法时，每个方法的拦截器会分配一个字段名
```java
public class TestController
implements EnhancedInstance {
   private volatile Object _$EnhancedClassField_ws;
   public static volatile /* synthetic */ InstMethodsInter _sw_delegate$8vbdac3$6;
   public static volatile /* synthetic */ InstMethodsInter _sw_delegate$8vbdac3$5;
   public static volatile /* synthetic */ ConstructorInter _sw_delegate$8vbdac3$4;
   public static volatile /* synthetic */ InstMethodsInter _sw_delegate$8vbdac3$3;
   public static volatile /* synthetic */ InstMethodsInter _sw_delegate$8vbdac3$2;
   public static volatile /* synthetic */ ConstructorInter _sw_delegate$8vbdac3$1;

   @RequestMapping(value={"/test"})
   @ResponseBody
   public String test() {
       return (String)_sw_delegate$8vbdac3$5.intercept((Object)this, new Object[0], (Callable)new TestController$sw_auxiliary$63vome2(this), cachedValue$8vbdac3$lt7gtc1);
   }

   @RequestMapping(value={"/http"})
   @ResponseBody
   public String testJdkHttpClient() {
       return (String)_sw_delegate$8vbdac3$5.intercept((Object)this, new Object[0], (Callable)new TestController$sw_auxiliary$ca62532(this), cachedValue$8vbdac3$lr4pe70);
   }
   ...
}
```
net.bytebuddy.implementation.MethodDelegation#to(java.lang.Object)<br />最终调用下面的方法，fieldName生成规则：`ImplementationDelegate.FIELD_NAME_PREFIX + "$" + RandomString.hashOf(target)`：
```java
public MethodDelegation to(Object target, Type type, MethodGraph.Compiler methodGraphCompiler) {
    return to(target,
            type,
            ImplementationDelegate.FIELD_NAME_PREFIX + "$" + RandomString.hashOf(target),
            methodGraphCompiler);
}
```


调试发现每次retransform时，target会发生变化，RandomString.hashOf(target) 也发生变化，导致field name发生变化。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682772414096-f66f2f3b-0086-4bf1-aa4e-00db6e50cbfa.png#averageHue=%23181817&clientId=u7a94a7b0-292b-4&from=paste&height=366&id=ucc9211be&originHeight=725&originWidth=1720&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=205763&status=done&style=none&taskId=u928be1ac-1c10-4a13-8133-e3bb7525d24&title=&width=868.6868080179681)

<a name="q4EqX"></a>
### 拦截器字段名生成器
分析代码发现一个指定field的构造代理方法：
```java
public MethodDelegation to(Object target, String fieldName) {
    return to(target, fieldName, MethodGraph.Compiler.DEFAULT);
}
```

从而想到一个解决办法： 指定代理方法的字段名。

分析Skywalking ClassEnhancePluginDefine 代理方法的逻辑：
```java
for (InstanceMethodsInterceptPoint instanceMethodsInterceptPoint : instanceMethodsInterceptPoints) {
    String interceptor = instanceMethodsInterceptPoint.getMethodsInterceptor();
    if (StringUtil.isEmpty(interceptor)) {
        throw new EnhanceException("no InstanceMethodsAroundInterceptor define to enhance class " + enhanceOriginClassName);
    }
    ElementMatcher.Junction<MethodDescription> junction = not(isStatic()).and(instanceMethodsInterceptPoint.getMethodsMatcher());
    if (instanceMethodsInterceptPoint instanceof DeclaredInstanceMethodsInterceptPoint) {
        junction = junction.and(ElementMatchers.<MethodDescription>isDeclaredBy(typeDescription));
    }
    if (instanceMethodsInterceptPoint.isOverrideArgs()) {
        if (isBootstrapInstrumentation()) {
            newClassBuilder = newClassBuilder.method(junction)
                    .intercept(MethodDelegation.withDefaultConfiguration()
                            .withBinders(Morph.Binder.install(OverrideCallable.class))
                            .to(BootstrapInstrumentBoost.forInternalDelegateClass(interceptor)));
        } else {
            newClassBuilder = newClassBuilder.method(junction)
                    .intercept(MethodDelegation.withDefaultConfiguration()
                            .withBinders(Morph.Binder.install(OverrideCallable.class))
                            .to(new InstMethodsInterWithOverrideArgs(interceptor, classLoader)));
        }
    } else {
        if (isBootstrapInstrumentation()) {
            newClassBuilder = newClassBuilder.method(junction)
                    .intercept(MethodDelegation.withDefaultConfiguration()
                            .to(BootstrapInstrumentBoost.forInternalDelegateClass(interceptor)));
        } else {
            newClassBuilder = newClassBuilder.method(junction)
                    .intercept(MethodDelegation.withDefaultConfiguration()
                            .to(new InstMethodsInter(interceptor, classLoader)));
        }
    }
}
}
```

```java
public interface InstanceMethodsInterceptPoint {
    /**
     * class instance methods matcher.
     *
     * @return methods matcher
     */
    ElementMatcher<MethodDescription> getMethodsMatcher();

    /**
     * @return represents a class name, the class instance must instanceof InstanceMethodsAroundInterceptor.
     */
    String getMethodsInterceptor();

    boolean isOverrideArgs();
}
```
发现比较难计算各种InterceptPoint的唯一id，其中net.bytebuddy.matcher.ElementMatcher 对象是可以多层嵌套，且使用了ByteBuddy的实现类，不方便重写。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682773214796-69b88275-0351-4261-be45-619ccea673d2.png#averageHue=%23fdfcdf&clientId=u7a94a7b0-292b-4&from=paste&height=475&id=u3fd2f04b&originHeight=941&originWidth=1061&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=151560&status=done&style=none&taskId=u56ec4147-4dfd-4d87-8866-44449e362e6&title=&width=535.8585484343396)

思考后发现，其实fieldName是什么不重要，但要满足下面几个条件：

- 同一个class的同一个代理方法的代理类名/field name相同
- 同一个class的不同代理方法的代理类名/field name不相同
- 子类和父类可能被同时增强，可能有方法重载，生成的代理类名/field name不能冲突（不能相同）
- 多次retransform class满足上面的条件

分析Skywalking ClassEnhancePluginDefine代码发现，处理流程及已加载插件数据的是固定不变的。如果每个class按代理方法顺序生成field name，理论上是可以满足上面的条件。至于第4点，可以在每次retransform前重置计数器。
```java
/**
 * Design to generate fixed delegate field name in retransform class
 */
public class DelegateNamingResolver {
    private static Map<String, AtomicInteger> NAME_CACHE = new ConcurrentHashMap<>();
    private final String enhanceOriginClassName;
    private final String fileNamePrefix;

    public DelegateNamingResolver(String enhanceOriginClassName) {
        this.enhanceOriginClassName = enhanceOriginClassName;
        // field name 中间部分使用enhanceOriginClassName的hashcode，避免子类生成fieldName相同
        fileNamePrefix = "_sw_delegate$" + RandomString.hashOf(enhanceOriginClassName.hashCode()) + "$";
    }

    public String next() {
        // 每次调用field index 增加1
        AtomicInteger index = NAME_CACHE.computeIfAbsent(enhanceOriginClassName, key -> new AtomicInteger(0));
        return fileNamePrefix + index.incrementAndGet();
    }

    public static DelegateNamingResolver get(String enhanceOriginClassName) {
        return new DelegateNamingResolver(enhanceOriginClassName);
    }

    /**
     * do reset before global retransform
     */
    public static void reset() {
        NAME_CACHE.clear();
    }
}
```
```java
public class SkyWalkingAgent {
    ...
	private static class Transformer implements AgentBuilder.Transformer {
        private PluginFinder pluginFinder;

        Transformer(PluginFinder pluginFinder) {
            this.pluginFinder = pluginFinder;
        }

        @Override
        public DynamicType.Builder<?> transform(final DynamicType.Builder<?> builder,
                                                final TypeDescription typeDescription,
                                                final ClassLoader classLoader,
                                                final JavaModule javaModule,
                                                final ProtectionDomain protectionDomain) {
            LoadedLibraryCollector.registerURLClassLoader(classLoader);
            DelegateNamingResolver.reset(); // transform 前重置计算器
            List<AbstractClassEnhancePluginDefine> pluginDefines = pluginFinder.find(typeDescription);
            if (pluginDefines.size() > 0) {
                DynamicType.Builder<?> newBuilder = builder.visit(new SWAsmVisitorWrapper());
                EnhanceContext context = new EnhanceContext();
                for (AbstractClassEnhancePluginDefine define : pluginDefines) {
                    DynamicType.Builder<?> possibleNewBuilder = define.define(
                        typeDescription, newBuilder, classLoader, context);
                    if (possibleNewBuilder != null) {
                        newBuilder = possibleNewBuilder;
                    }
                }
                return newBuilder;
            }
            return builder;
        }
    }
}
```

```java
// ClassEnhancePluginDefine, ClassEnhancePluginDefineV2
protected DynamicType.Builder<?> enhanceInstance(TypeDescription typeDescription,
                                                 DynamicType.Builder<?> newClassBuilder, ClassLoader classLoader,
                                                 EnhanceContext context) throws PluginException {
    ConstructorInterceptPoint[] constructorInterceptPoints = getConstructorsInterceptPoints();
    InstanceMethodsInterceptPoint[] instanceMethodsInterceptPoints = getInstanceMethodsInterceptPoints();
    ...
    // 获取增强的class的field name生成器
    DelegateNamingResolver delegateNamingResolver = DelegateNamingResolver.get(typeDescription.getTypeName());
    ...

    /**
     * 3. enhance instance methods
     */
    if (existedMethodsInterceptPoints) {
        for (InstanceMethodsInterceptPoint instanceMethodsInterceptPoint : instanceMethodsInterceptPoints) {
            String interceptor = instanceMethodsInterceptPoint.getMethodsInterceptor();
            if (StringUtil.isEmpty(interceptor)) {
                throw new EnhanceException("no InstanceMethodsAroundInterceptor define to enhance class " + enhanceOriginClassName);
            }
            ...
            // 按顺序调用 delegateNamingResolver.next() 
            if (instanceMethodsInterceptPoint.isOverrideArgs()) {
                if (isBootstrapInstrumentation()) {
                    newClassBuilder = newClassBuilder.method(junction)
                            .intercept(MethodDelegation.withDefaultConfiguration()
                                    .withBinders(Morph.Binder.install(OverrideCallable.class))
                                    .to(BootstrapInstrumentBoost.forInternalDelegateClass(interceptor), delegateNamingResolver.next()));
                } else {
                    newClassBuilder = newClassBuilder.method(junction)
                            .intercept(MethodDelegation.withDefaultConfiguration()
                                    .withBinders(Morph.Binder.install(OverrideCallable.class))
                                    .to(new InstMethodsInterWithOverrideArgs(interceptor, classLoader), delegateNamingResolver.next()));
                }
            } else {
				...
            }
        }
    }

    return newClassBuilder;
}
```

<a name="WC0bZ"></a>
### 静态方法代理和实例方法代理
增强java.util.concurrent.ThreadPoolExecutor 时失败，打印错误日志时又触发增强java.util.concurrent.ThreadPoolExecutor，触发java.lang.ClassCircularityError
```java
"main@1" prio=5 tid=0x1 nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at java.util.concurrent.Executors.newSingleThreadScheduledExecutor(Executors.java:276)
	  at org.apache.skywalking.apm.agent.core.logging.core.FileWriter.<init>(FileWriter.java:66)
	  at org.apache.skywalking.apm.agent.core.logging.core.FileWriter.get(FileWriter.java:56)
	  - locked <0xc99> (a java.lang.Object)
	  at org.apache.skywalking.apm.agent.core.logging.core.WriterFactory.getLogWriter(WriterFactory.java:49)
	  at org.apache.skywalking.apm.agent.core.logging.core.AbstractLogger.logger(AbstractLogger.java:207)
	  at org.apache.skywalking.apm.agent.core.logging.core.AbstractLogger.error(AbstractLogger.java:100)
	  at org.apache.skywalking.apm.agent.SkyWalkingAgent$Listener.onError(SkyWalkingAgent.java:243)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Listener$Compound.onError(AgentBuilder.java:2420)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:12169)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1800(AgentBuilder.java:11869)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:12647)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:12579)
	  at java.security.AccessController.doPrivileged(AccessController.java:-1)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doPrivileged(AgentBuilder.java:12055)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:12103)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$ByteBuddy$ModuleSupport.transform(Unknown Source:-1)
	  at sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	  at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:563)
	  at java.util.concurrent.Executors.newSingleThreadExecutor(Executors.java:194)
	  at org.apache.skywalking.apm.agent.core.commands.CommandService.<init>(CommandService.java:43)
	  at jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(NativeConstructorAccessorImpl.java:-1)
	  at jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	  at jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	  at java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	  at java.util.ServiceLoader$ProviderImpl.newInstance(ServiceLoader.java:779)
	  at java.util.ServiceLoader$ProviderImpl.get(ServiceLoader.java:721)
	  at java.util.ServiceLoader$3.next(ServiceLoader.java:1394)
	  at org.apache.skywalking.apm.agent.core.boot.ServiceManager.load(ServiceManager.java:144)
	  at org.apache.skywalking.apm.agent.core.boot.ServiceManager.loadAllServices(ServiceManager.java:62)
	  at org.apache.skywalking.apm.agent.core.boot.ServiceManager.boot(ServiceManager.java:42)
	  at org.apache.skywalking.apm.agent.SkyWalkingAgent.premain(SkyWalkingAgent.java:159)
	  at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)
	  at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	  at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	  at java.lang.reflect.Method.invoke(Method.java:566)
	  at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:513)
	  at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:525)

```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682180090978-d82f65f9-db2c-4d0c-bebb-ed5c850d2abf.png#averageHue=%23f6f4ec&clientId=u6de8bf5a-f234-4&from=paste&height=321&id=u729e93f5&originHeight=635&originWidth=2490&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=207679&status=done&style=none&taskId=u6cdbdeb0-4f59-43e8-80d3-8ba7ed3a845&title=&width=1257.5756697469421)

```java
java.lang.ClassCircularityError: java/util/concurrent/ThreadPoolExecutor
        at java.base/java.util.concurrent.Executors.newSingleThreadScheduledExecutor(Executors.java:276)
        at org.apache.skywalking.apm.agent.core.profile.ProfileTaskExecutionService.<clinit>(ProfileTaskExecutionService.java:49)
        at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
        at java.base/java.util.ServiceLoader$ProviderImpl.newInstance(ServiceLoader.java:779)
        at java.base/java.util.ServiceLoader$ProviderImpl.get(ServiceLoader.java:721)
        at java.base/java.util.ServiceLoader$3.next(ServiceLoader.java:1394)
        at org.apache.skywalking.apm.agent.core.boot.ServiceManager.load(ServiceManager.java:144)
        at org.apache.skywalking.apm.agent.core.boot.ServiceManager.loadAllServices(ServiceManager.java:62)
        at org.apache.skywalking.apm.agent.core.boot.ServiceManager.boot(ServiceManager.java:42)
        at org.apache.skywalking.apm.agent.SkyWalkingAgent.premain(SkyWalkingAgent.java:159)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)
        at java.instrument/sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:513)
        at java.instrument/sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:525)


```

分析发现启动时 retransform java.util.concurrent.ScheduledThreadPoolExecutor.execute(java.lang.Runnable) 抛出错误
```java
java.lang.IllegalArgumentException: Cannot resolve ambiguous delegation of public void java.util.concurrent.ScheduledThreadPoolExecutor.execute(java.lang.Runnable) to public java.lang.Class java.lang.Class.getNestHost() or public java.lang.Class[] java.lang.Class.getNestMembers()	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:639)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:650)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:650)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:650)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:650)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:650)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:658)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:653)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:650)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:650)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:650)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:650)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.doResolve(MethodDelegationBinder.java:653)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$BindingResolver$Default.resolve(MethodDelegationBinder.java:614)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.bind.MethodDelegationBinder$Processor.bind(MethodDelegationBinder.java:1101)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.implementation.MethodDelegation$Appender.apply(MethodDelegation.java:1346)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyCode(TypeWriter.java:730)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyBody(TypeWriter.java:715)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining$WithFullProcessing$RedefinitionClassVisitor$CodePreservingMethodVisitor.visitCode(TypeWriter.java:5502)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.jar.asm.ClassReader.readMethod(ClassReader.java:1513)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:744)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:424)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:4014)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:2224)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase$UsingTypeWriter.make(DynamicType.java:4057)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doTransform(AgentBuilder.java:12106)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:12041)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1800(AgentBuilder.java:11758)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:12521)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:12453)
	  at java.security.AccessController.doPrivileged(AccessController.java:-1)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doPrivileged(AgentBuilder.java:11936)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:11984)
	  at org.apache.skywalking.apm.dependencies.net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$ByteBuddy$ModuleSupport.transform(Unknown Source:-1)
	  at sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	  at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:563)
	  at java.util.concurrent.Executors.newSingleThreadScheduledExecutor(Executors.java:276)
	  at org.apache.skywalking.apm.agent.core.logging.core.FileWriter.<init>(FileWriter.java:66)
	  at org.apache.skywalking.apm.agent.core.logging.core.FileWriter.get(FileWriter.java:56)
	  - locked <0xc43> (a java.lang.Object)
	  at org.apache.skywalking.apm.agent.core.logging.core.WriterFactory.getLogWriter(WriterFactory.java:49)
	  at org.apache.skywalking.apm.agent.core.logging.core.AbstractLogger.logger(AbstractLogger.java:207)
	  at org.apache.skywalking.apm.agent.core.logging.core.AbstractLogger.info(AbstractLogger.java:65)
	  at org.apache.skywalking.apm.agent.SkyWalkingAgent.premain(SkyWalkingAgent.java:158)
	  at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)
	  at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	  at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	  at java.lang.reflect.Method.invoke(Method.java:566)
	  at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:513)
	  at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:525)

```

分析原始Skywalking-agent 的方法代理逻辑：<br />java.util.concurrent.ThreadPoolExecutor  <br />prepare:959, MethodDelegation$ImplementationDelegate$ForStaticMethod<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682183389750-d5f01d39-c7d1-4d51-aa17-20036baea281.png#averageHue=%23f2efeb&clientId=u6de8bf5a-f234-4&from=paste&height=598&id=u6bea5e81&originHeight=1185&originWidth=2538&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=251833&status=done&style=none&taskId=u1306612b-5170-4aa6-9a29-d891617efc4&title=&width=1281.8180922962808)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682183616981-60335c96-53c4-4c75-bcc1-a9da0eecc42a.png#averageHue=%23f0efeb&clientId=u6de8bf5a-f234-4&from=paste&height=587&id=ucebbaa3e&originHeight=1163&originWidth=2497&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=261251&status=done&style=none&taskId=u4a0fed45-b579-4186-a208-35ac5480a1c&title=&width=1261.1110230353875)

修改后出现问题的代理逻辑：<br /> java.util.concurrent.ThreadPoolExecutor   <br />prepare:1084, MethodDelegation$ImplementationDelegate$ForField$WithInstance<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682183682436-236682d0-5b01-414a-8263-1b06302c911b.png#averageHue=%23f1efeb&clientId=u6de8bf5a-f234-4&from=paste&height=611&id=uc1e0fa4e&originHeight=1209&originWidth=2529&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=299180&status=done&style=none&taskId=uf4fcb6f6-1db5-4275-a709-1dc4ce30b04&title=&width=1277.2726380682798)

检查代码 MethodDelegation 代码，发现MethodDelegation.to( class )  方法执行创建的是ImplementationDelegate.ForStaticMethod 子类<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682183796842-3b348982-7ba9-41f4-8e91-13474ab8c717.png#averageHue=%23f0eae8&clientId=u6de8bf5a-f234-4&from=paste&height=329&id=u819737f0&originHeight=651&originWidth=2377&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=147954&status=done&style=none&taskId=u79e5011a-3ef2-4249-8de1-2123b46a4b3&title=&width=1200.5049666620407)

解决办法；

- 对应class静态方法需要使用ForStaticMethod方式，即不需要使用delegateNamingResolver.next()生成field name。
- 对于class实例方法需要保证每次生成相同的field name。
```java
    if (isBootstrapInstrumentation()) {
        newClassBuilder = newClassBuilder.method(
                        isStatic().and(staticMethodsInterceptV2Point.getMethodsMatcher()))
                .intercept(MethodDelegation.withDefaultConfiguration()
                        .to(BootstrapInstrumentBoost.forInternalDelegateClass(interceptor)));
    } else {
        newClassBuilder = newClassBuilder.method(
                        isStatic().and(staticMethodsInterceptV2Point.getMethodsMatcher()))
                .intercept(MethodDelegation.withDefaultConfiguration()
                        .to(new StaticMethodsInterV2(interceptor), delegateNamingResolver.next()));
    }
```
<a name="mZNhw"></a>
## 辅助类名
<a name="In1o7"></a>
### AuxiliaryType.NamingStrategy
辅助类名通过AuxiliaryType.NamingStrategy生成，ByteBuddy 升级到1.12后，增加了AuxiliaryType参数，并提供了几个实现类。
```java
    interface NamingStrategy {

        /**
         * Names an auxiliary type.
         *
         * @param instrumentedType The instrumented type for which an auxiliary type is registered.
         * @param auxiliaryType    The named auxiliary type.
         * @return The fully qualified name for the given auxiliary type.
         */
        String name(TypeDescription instrumentedType, AuxiliaryType auxiliaryType);
    }
```

- net.bytebuddy.implementation.auxiliary.AuxiliaryType.NamingStrategy.Suffixing

类名后缀使用auxiliaryType.getSuffix()，很大程度保持稳定，但存在一些问题，后续分析到MethodCallProxy.getSuffix() 没发区分方法重载不同的参数的场景。
```java
public String name(TypeDescription instrumentedType, AuxiliaryType auxiliaryType) {
    return instrumentedType.getName() + "$" + suffix + "$" + auxiliaryType.getSuffix();
}
```

- net.bytebuddy.implementation.auxiliary.AuxiliaryType.NamingStrategy.SuffixingRandom

使用随机字符串后缀，每次生成的都不一样。
```java
public String name(TypeDescription instrumentedType, AuxiliaryType auxiliaryType) {
    return instrumentedType.getName() + "$" + suffix + "$" + randomString.nextString();
}
```

- net.bytebuddy.implementation.auxiliary.AuxiliaryType.NamingStrategy.Enumerating

使用auxiliaryType对象的hashcode，跟踪发现是System.identityHashCode()，不是调用Object.hashcode()，看起来是一个BUG。存在的问题：AuxiliaryType内容相同，对象不同时hashcode不一样。<br />参考这里：
```java
public String name(TypeDescription instrumentedType, AuxiliaryType auxiliaryType) {
    return instrumentedType.getName() + "$" + suffix + "$" + RandomString.hashOf(auxiliaryType);
}
```
```java
public class RandomString {
    public static String hashOf(@MaybeNull Object value) {
        return hashOf(value == null
                ? 0
                : value.getClass().hashCode() ^ System.identityHashCode(value));
    }
}
```

ByteBuddy默认构造方法使用AuxiliaryType.NamingStrategy.SuffixingRandom，即使用随机字符串后缀，每次生成的都不一样。
```java
public ByteBuddy(ClassFileVersion classFileVersion) {
    this(classFileVersion,
            DEFAULT_NAMING_STRATEGY == null
                    ? new NamingStrategy.SuffixingRandom(BYTE_BUDDY_DEFAULT_PREFIX)
                    : DEFAULT_NAMING_STRATEGY,
            DEFAULT_AUXILIARY_NAMING_STRATEGY == null
                    ? new AuxiliaryType.NamingStrategy.SuffixingRandom(BYTE_BUDDY_DEFAULT_SUFFIX)
                    : DEFAULT_AUXILIARY_NAMING_STRATEGY,
            AnnotationValueFilter.Default.APPEND_DEFAULTS,
            AnnotationRetention.ENABLED,
            DEFAULT_IMPLEMENTATION_CONTEXT_FACTORY == null
                    ? Implementation.Context.Default.Factory.INSTANCE
                    : DEFAULT_IMPLEMENTATION_CONTEXT_FACTORY,
            MethodGraph.Compiler.DEFAULT,
            InstrumentedType.Factory.Default.MODIFIABLE,
            TypeValidation.ENABLED,
            VisibilityBridgeStrategy.Default.ALWAYS,
            ClassWriterStrategy.Default.CONSTANT_POOL_RETAINING,
            new LatentMatcher.Resolved<MethodDescription>(isSynthetic().or(isDefaultFinalizer())));
}
```
综合判断，修改为Suffixing实现。
```java
final ByteBuddy byteBuddy = new ByteBuddy()
	.with(new AuxiliaryType.NamingStrategy.Suffixing("sw_auxiliary"))

```

启用 apm-jdk-threadpool plugin 后，应用启动 ThreadPoolExecutor.execute() 执行报错
```java
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1
	at java.base/java.util.concurrent.ThreadPoolExecutor$sw_auxiliary$iv6mdg30.call(Unknown Source)
	at org.apache.skywalking.apm.plugin.ThreadPoolExecuteMethodInterceptor_internal.intercept(InstanceMethodInterWithOverrideArgsTemplate.java:87)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java)
	at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl$ExecutorHolder.execute(ManagedChannelImpl.java:2229)
	at org.apache.skywalking.apm.dependencies.io.grpc.internal.DnsNameResolver.resolve(DnsNameResolver.java:389)
	at org.apache.skywalking.apm.dependencies.io.grpc.internal.DnsNameResolver.start(DnsNameResolver.java:206)
	at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl.exitIdleMode(ManagedChannelImpl.java:418)
	at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl$RealChannel$2.run(ManagedChannelImpl.java:981)
	at org.apache.skywalking.apm.dependencies.io.grpc.SynchronizationContext.drain(SynchronizationContext.java:95)
	at org.apache.skywalking.apm.dependencies.io.grpc.SynchronizationContext.execute(SynchronizationContext.java:127)
	at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl$RealChannel.newCall(ManagedChannelImpl.java:978)
	at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl.newCall(ManagedChannelImpl.java:920)
	at org.apache.skywalking.apm.dependencies.io.grpc.internal.ForwardingManagedChannel.newCall(ForwardingManagedChannel.java:63)
	at org.apache.skywalking.apm.agent.core.remote.AgentIDDecorator$1.interceptCall(AgentIDDecorator.java:43)
	at org.apache.skywalking.apm.dependencies.io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
	at org.apache.skywalking.apm.network.event.v3.EventServiceGrpc$EventServiceStub.collect(EventServiceGrpc.java:146)
	at org.apache.skywalking.apm.agent.core.remote.EventReportServiceClient.reportStartingEvent(EventReportServiceClient.java:164)
	at org.apache.skywalking.apm.agent.core.remote.EventReportServiceClient.statusChanged(EventReportServiceClient.java:156)
	at org.apache.skywalking.apm.agent.core.remote.GRPCChannelManager.notify(GRPCChannelManager.java:195)
	at org.apache.skywalking.apm.agent.core.remote.GRPCChannelManager.run(GRPCChannelManager.java:151)
	... 7 more
```

Arthas 执行命令也报错
```java
ERROR 2023-04-23 01:37:11.730 arthas-NettyHttpTelnetBootstrap-3-2 org.apache.skywalking.apm.plugin.ThreadPoolExecuteMethodInterceptor_internal : class[class java.util.concurrent.ScheduledThreadPoolExecutor] handle method[execute] exception failure 
java.lang.NullPointerException
	at org.apache.skywalking.apm.agent.core.context.ContextManager.activeSpan(ContextManager.java:184)
	at org.apache.skywalking.apm.plugin.AbstractThreadingPoolInterceptor.handleMethodException(AbstractThreadingPoolInterceptor.java:60)
	at org.apache.skywalking.apm.plugin.ThreadPoolExecuteMethodInterceptor_internal.intercept(InstanceMethodInterWithOverrideArgsTemplate.java:92)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor.execute(ScheduledThreadPoolExecutor.java)
	at com.taobao.arthas.core.server.ArthasBootstrap.execute(ArthasBootstrap.java:597)
	at com.taobao.arthas.core.shell.system.impl.ProcessImpl.run(ProcessImpl.java:371)
	at com.taobao.arthas.core.shell.system.impl.JobImpl.run(JobImpl.java:219)
	at com.taobao.arthas.core.shell.system.impl.JobImpl.run(JobImpl.java:203)
	at com.taobao.arthas.core.shell.handlers.shell.ShellLineHandler.handle(ShellLineHandler.java:63)
	at com.taobao.arthas.core.shell.handlers.shell.ShellLineHandler.handle(ShellLineHandler.java:17)
	at com.taobao.arthas.core.shell.handlers.term.RequestHandler.accept(RequestHandler.java:22)
	at com.taobao.arthas.core.shell.handlers.term.RequestHandler.accept(RequestHandler.java:10)
	at io.termd.core.readline.Readline$Interaction.end(Readline.java:231)
	at io.termd.core.readline.Readline$Interaction.access$000(Readline.java:187)
	at io.termd.core.readline.Readline$2.apply(Readline.java:487)
	at io.termd.core.readline.Readline$Interaction.handle(Readline.java:272)
	at io.termd.core.readline.Readline$Interaction.access$200(Readline.java:187)
```
报ClassCastException，看起来是同名方法的delegate存在问题
```java
java.lang.ClassCastException: class com.taobao.arthas.core.shell.system.impl.ProcessImpl$CommandProcessTask cannot be cast to class java.util.concurrent.Callable (com.taobao.arthas.core.shell.system.impl.
ProcessImpl$CommandProcessTask is in unnamed module of loader com.taobao.arthas.agent.ArthasClassloader @460ef931; java.util.concurrent.Callable is in module java.base of loader 'bootstrap')
        at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$sw_auxiliary$iv6mdg30.call(Unknown Source)
        at org.apache.skywalking.apm.plugin.ThreadPoolExecuteMethodInterceptor_internal.intercept(InstanceMethodInterWithOverrideArgsTemplate.java:87)
        at java.base/java.util.concurrent.ScheduledThreadPoolExecutor.execute(ScheduledThreadPoolExecutor.java)
        at com.taobao.arthas.core.server.ArthasBootstrap.execute(ArthasBootstrap.java:597)
        at com.taobao.arthas.core.shell.system.impl.ProcessImpl.run(ProcessImpl.java:371)
        at com.taobao.arthas.core.shell.system.impl.JobImpl.run(JobImpl.java:219)
        at com.taobao.arthas.core.shell.system.impl.JobImpl.run(JobImpl.java:203)
        at com.taobao.arthas.core.shell.handlers.shell.ShellLineHandler.handle(ShellLineHandler.java:63)
        at com.taobao.arthas.core.shell.handlers.shell.ShellLineHandler.handle(ShellLineHandler.java:17)
        at com.taobao.arthas.core.shell.handlers.term.RequestHandler.accept(RequestHandler.java:22)
        at com.taobao.arthas.core.shell.handlers.term.RequestHandler.accept(RequestHandler.java:10)
        at io.termd.core.readline.Readline$Interaction.end(Readline.java:231)
        at io.termd.core.readline.Readline$Interaction.access$000(Readline.java:187)

```

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682185825629-65ae42c7-1425-49c7-ac4a-4cb3ad8fa97d.png#averageHue=%23e7d091&clientId=ucac5b3ca-f60b-4&from=paste&height=90&id=udce06040&originHeight=179&originWidth=800&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=22018&status=done&style=none&taskId=u11827ee9-f15e-4ebe-9a77-746886b6557&title=&width=404.04037582231075)

```java
4月 29, 2023 4:54:06 下午 org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl$2 uncaughtException
严重: [Channel<1>: (127.0.0.1:11800)] Uncaught exception in the SynchronizationContext. Panic!
java.lang.ClassCastException: class org.apache.skywalking.apm.dependencies.io.grpc.internal.DnsNameResolver$Resolve cannot be cast to class java.util.concurrent.Callable (org.apache.skywalking.apm.depende
ncies.io.grpc.internal.DnsNameResolver$Resolve is in unnamed module of loader 'app'; java.util.concurrent.Callable is in module java.base of loader 'bootstrap')
        at java.base/java.util.concurrent.ThreadPoolExecutor$sw_auxiliary$iv6mdg30.call(Unknown Source)
        at org.apache.skywalking.apm.plugin.ThreadPoolExecuteMethodInterceptor_internal.intercept(InstanceMethodInterWithOverrideArgsTemplate.java:87)
        at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java)
        at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl$ExecutorHolder.execute(ManagedChannelImpl.java:2229)
        at org.apache.skywalking.apm.dependencies.io.grpc.internal.DnsNameResolver.resolve(DnsNameResolver.java:389)
        at org.apache.skywalking.apm.dependencies.io.grpc.internal.DnsNameResolver.start(DnsNameResolver.java:206)
        at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl.exitIdleMode(ManagedChannelImpl.java:418)
        at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl$RealChannel$2.run(ManagedChannelImpl.java:981)
        at org.apache.skywalking.apm.dependencies.io.grpc.SynchronizationContext.drain(SynchronizationContext.java:95)
        at org.apache.skywalking.apm.dependencies.io.grpc.SynchronizationContext.execute(SynchronizationContext.java:127)
        at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl$RealChannel.newCall(ManagedChannelImpl.java:978)
        at org.apache.skywalking.apm.dependencies.io.grpc.internal.ManagedChannelImpl.newCall(ManagedChannelImpl.java:920)
        at org.apache.skywalking.apm.dependencies.io.grpc.internal.ForwardingManagedChannel.newCall(ForwardingManagedChannel.java:63)
        at org.apache.skywalking.apm.agent.core.remote.AgentIDDecorator$1.interceptCall(AgentIDDecorator.java:43)
        at org.apache.skywalking.apm.dependencies.io.grpc.ClientInterceptors$InterceptorChannel.newCall(ClientInterceptors.java:156)
        at org.apache.skywalking.apm.network.event.v3.EventServiceGrpc$EventServiceStub.collect(EventServiceGrpc.java:146)
        at org.apache.skywalking.apm.agent.core.remote.EventReportServiceClient.reportStartingEvent(EventReportServiceClient.java:164)
        at org.apache.skywalking.apm.agent.core.remote.EventReportServiceClient.statusChanged(EventReportServiceClient.java:156)
        at org.apache.skywalking.apm.agent.core.remote.GRPCChannelManager.notify(GRPCChannelManager.java:195)
        at org.apache.skywalking.apm.agent.core.remote.GRPCChannelManager.run(GRPCChannelManager.java:151)
        at org.apache.skywalking.apm.util.RunnableWithExceptionProtection.run(RunnableWithExceptionProtection.java:33)
        at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
        at java.base/java.util.concurrent.FutureTask.runAndReset(FutureTask.java:305)
        at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:305)
        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
        at java.base/java.lang.Thread.run(Thread.java:834)


```

<a name="ceHWX"></a>
### AuxiliaryType.NamingStrategy.Suffixing
开启Skywalking Agent class调试，然后重启应用：export SW_AGENT_OPEN_DEBUG=true<br />Skywalking agent 增强的class保存到skywalking-agent/debugging 目录中，使用IDEA/JD-GUI等工具打开java\util\concurrent\ThreadPoolExecutor.class，查看增强的execute和submit方法：
```java
public void execute(Runnable var1) {
    ThreadPoolExecuteMethodInterceptor_internal.intercept(this, new Object[]{var1}, new ThreadPoolExecutor$sw_auxiliary$iv6mdg30(this), cachedValue$g28bpd0$gtalt20);
}

public Future<?> submit(Runnable var1) {
    return (Future)ThreadPoolSubmitMethodInterceptor_internal.intercept(this, new Object[]{var1}, new ThreadPoolExecutor$sw_auxiliary$iv6mdg30(this), cachedValue$g28bpd0$ko5i9p1);
}

public <T> Future<T> submit(Runnable var1, T var2) {
    return (Future)ThreadPoolSubmitMethodInterceptor_internal.intercept(this, new Object[]{var1, var2}, new ThreadPoolExecutor$sw_auxiliary$iv6mdg30(this), cachedValue$g28bpd0$7cmcph0);
}

public <T> Future<T> submit(Callable<T> var1) {
    return (Future)ThreadPoolSubmitMethodInterceptor_internal.intercept(this, new Object[]{var1}, new ThreadPoolExecutor$sw_auxiliary$iv6mdg30(this), cachedValue$g28bpd0$i1a46q0);
}
```
```java
package java.util.concurrent;

import org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.OverrideCallable;

// $FF: synthetic class
class ThreadPoolExecutor$sw_auxiliary$iv6mdg30 implements OverrideCallable {
    private final ThreadPoolExecutor target;

    public Object call(Object[] var1) {
        return this.target.submit$accessor$g28bpd0((Callable)var1[0]);
    }

    ThreadPoolExecutor$sw_auxiliary$iv6mdg30(ThreadPoolExecutor var1) {
        this.target = var1;
    }
}
```
ThreadPoolExecutor 的三个submit方法参数不同，但使用了同一个辅助类`ThreadPoolExecutor$sw_auxiliary$iv6mdg30`，导致运行时报错ClassCastException。

上面的问题是生成辅助类(auxiliaryType)名的问题，定位到使用的AuxiliaryType.NamingStrategy实现类的方法`String name(TypeDescription instrumentedType, AuxiliaryType auxiliaryType) `<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682759663150-be6bdad1-aedd-4939-ad52-c4e989d8cb99.png#averageHue=%23f1f0ec&clientId=u774d2d28-e5a8-4&from=paste&height=575&id=u88a9eebc&originHeight=1139&originWidth=2522&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=256813&status=done&style=none&taskId=u2d62a599-a6f0-4550-b984-ffb25a004ed&title=&width=1273.7372847798347)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682759702403-a3cd3ea8-fc2a-4d38-bcd9-0702d6804611.png#averageHue=%23f2f0ec&clientId=u774d2d28-e5a8-4&from=paste&height=576&id=uab8af410&originHeight=1140&originWidth=2480&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=283653&status=done&style=none&taskId=ua7261da7-3665-4ebd-a428-4c855ea425b&title=&width=1252.5251650491632)<br />发现生成辅助类时使用AuxiliaryType.NamingStrategy.Suffixing实现类，类名后缀使用auxiliaryType.getSuffix()，跟踪进去使用了TypeDescription.AbstractBase#hashCode() getName().hashcode()，没有使用到代理方法的信息。<br />当同一个类代理多个方法时，需生成多个不同的辅助类，按照`AuxiliaryType.NamingStrategy.Suffixing`策略，导致生成的辅助类名相同，最终只会生成其中一个代理方法的辅助类，导致重载的几个方法都使用相同辅助类，出现类型转换失败错误。

<a name="oznpo"></a>
### AuxiliaryType.NamingStrategy.Enumerating
修改使用内置的AuxiliaryType.NamingStrategy.Enumerating：
```java
ByteBuddy byteBuddy = new ByteBuddy()
	.with(new AuxiliaryType.NamingStrategy.Enumerating("sw_auxiliary"))
```
```java
    class Enumerating implements NamingStrategy {
		...
        public String name(TypeDescription instrumentedType, AuxiliaryType auxiliaryType) {
            return instrumentedType.getName() + "$" + suffix + "$" + RandomString.hashOf(auxiliaryType);
        }
    }
```
应用启动时不再报错，分析生成的代码java.util.concurrent.ThreadPoolExecutor 的4个代理方法使用了不同的auxiliary class：
```java
    public void execute(Runnable var1) {
        ThreadPoolExecuteMethodInterceptor_internal.intercept(this, new Object[]{var1}, new 5tfm5j1(this), cachedValue$g28bpd0$gtalt20);
    }

    public Future<?> submit(Runnable var1) {
        return (Future)ThreadPoolSubmitMethodInterceptor_internal.intercept(this, new Object[]{var1}, new lt8ce90(this), cachedValue$g28bpd0$ko5i9p1);
    }

    public <T> Future<T> submit(Runnable var1, T var2) {
        return (Future)ThreadPoolSubmitMethodInterceptor_internal.intercept(this, new Object[]{var1, var2}, new ai5r5e0(this), cachedValue$g28bpd0$7cmcph0);
    }

    public <T> Future<T> submit(Callable<T> var1) {
        return (Future)ThreadPoolSubmitMethodInterceptor_internal.intercept(this, new Object[]{var1}, new 8brik90(this), cachedValue$g28bpd0$i1a46q0);
    }

```

多次执行 arthas 命令： `jad --source java.util.concurrent.ThreadPoolExecutor submit`<br />发现每次输出的方法内容的辅助类不同，所以上面改为`AuxiliaryType.NamingStrategy.Enumerating` 还是没有解决多次生成代码发生改变的问题。原因是每次retransform同一个类的同一个方法生成auxiliaryType对象不同，RandomString.hashOf(auxiliaryType) 发生变化。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682761513935-a03e8b36-9edf-43f5-b090-d5acee483710.png#averageHue=%231a1615&clientId=u910f17ce-8a2d-4&from=paste&height=493&id=u42f673de&originHeight=977&originWidth=1706&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=184954&status=done&style=none&taskId=u4a919604-fcc9-481a-ae85-492ed1bf879&title=&width=861.6161014410776)

<a name="WUuNr"></a>
### 自定义AuxiliaryType$NamingStrategy
尝试自定义实现类 `AuxiliaryType$NamingStrategy`，目标是让同一个代理方法的AuxiliaryType name保持不变。分析发现AuxiliaryType的子类带有代理的原始方法信息，通过类反射可以提取出来，根据原始方法签名生成hashcode。这样同一个类的同一个方法两次retransform生成的AuxiliaryType name保持一致。 
```java
public class SWAuxiliaryTypeNamingStrategy implements AuxiliaryType.NamingStrategy {
    private String suffix;

    public SWAuxiliaryTypeNamingStrategy(String suffix) {
        this.suffix = suffix;
    }

    @Override
    public String name(TypeDescription instrumentedType, AuxiliaryType auxiliaryType) {
        String description = findDescription(auxiliaryType);
        if (description != null) {
            return instrumentedType.getName() + "$" + suffix + "$" + RandomString.hashOf(description.hashCode());
        }
        return instrumentedType.getName() + "$" + suffix + "$" + RandomString.hashOf(auxiliaryType);
    }

    private String findDescription(AuxiliaryType auxiliaryType) {
        try {
            Class<? extends AuxiliaryType> auxiliaryTypeClass = auxiliaryType.getClass();
            String auxiliaryTypeClassName = auxiliaryTypeClass.getName();
            if (auxiliaryTypeClassName.endsWith("Morph$Binder$RedirectionProxy") || auxiliaryTypeClassName.endsWith("MethodCallProxy")) {
                // get MethodDescription from 'specialMethodInvocation.methodDescription'
                Field specialMethodInvocationField = auxiliaryTypeClass.getDeclaredField("specialMethodInvocation");
                specialMethodInvocationField.setAccessible(true);
                SpecialMethodInvocation specialMethodInvocation = (SpecialMethodInvocation) specialMethodInvocationField.get(auxiliaryType);
                MethodDescription methodDescription = specialMethodInvocation.getMethodDescription();
                return methodDescription.toString();
            } else if (auxiliaryTypeClassName.endsWith("Pipe$Binder$RedirectionProxy")) {
                // get sourceMethod (MethodDescription)
                Field sourceMethodField = auxiliaryTypeClass.getDeclaredField("sourceMethod");
                sourceMethodField.setAccessible(true);
                MethodDescription sourceMethod = (MethodDescription) sourceMethodField.get(auxiliaryType);
                return sourceMethod.toString();
            } else if (auxiliaryTypeClassName.endsWith("FieldProxy$Binder$AccessorProxy")) {
                // get fieldDescription
                Field fieldDescriptionField = auxiliaryTypeClass.getDeclaredField("fieldDescription");
                fieldDescriptionField.setAccessible(true);
                FieldDescription fieldDescription = (FieldDescription) fieldDescriptionField.get(auxiliaryType);
                return fieldDescription.toString();
            }
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return null;
    }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682764158963-4bfd0aea-46ed-4dde-9be5-7265bf75deb1.png#averageHue=%23181717&clientId=u910f17ce-8a2d-4&from=paste&height=459&id=uadb0e240&originHeight=909&originWidth=1710&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=181549&status=done&style=none&taskId=u9ec7a4ba-27b1-4142-a84c-0eee1a58315&title=&width=863.6363033201892)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/2391732/1682764236854-cd775644-6b4e-43c4-b7a1-c84b60872107.png#averageHue=%23f9f8f7&clientId=u910f17ce-8a2d-4&from=paste&height=277&id=ucde82b6c&originHeight=548&originWidth=1307&originalType=binary&ratio=1.9800001382827759&rotation=0&showTitle=false&size=70090&status=done&style=none&taskId=uf9202a42-28ff-40dd-b381-8db6c2e89ff&title=&width=660.1009639997002)<br />多次执行`jad --source java.util.concurrent.ThreadPoolExecutor submit` 命令，可以看到方法内容的辅助类是相同的，没有生成新的辅助类，达成目标！


